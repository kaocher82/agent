<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI GitHub Agent Manager</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex items-center justify-center min-h-screen">
    <div class="w-full max-w-4xl mx-auto p-8 bg-gray-800 rounded-2xl shadow-2xl">
        <div class="text-center mb-8">
            <h1 class="text-4xl font-bold text-white">AI GitHub Agent Manager</h1>
            <p class="text-gray-400 mt-2">Your AI-powered assistant for managing GitHub repositories.</p>
        </div>

        <div class="space-y-6">
            <div>
                <label for="repoUrl" class="block text-sm font-medium text-gray-300 mb-2">GitHub Repository URL</label>
                <input type="text" id="repoUrl" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="e.g., https://github.com/your-username/your-repo" value="https://github.com/kaocher82/AI.git">
            </div>

            <div>
                <label for="command" class="block text-sm font-medium text-gray-300 mb-2">AI Command</label>
                <textarea id="command" rows="4" class="w-full bg-gray-700 border border-gray-600 rounded-lg px-4 py-3 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="e.g., Create a new file named 'index.js' with a simple console.log statement.">Create a basic CI workflow file that triggers on a pull request to the 'main' branch. It should check out the code and run a simple echo command.</textarea>
            </div>

            <button id="executeBtn" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg transition duration-300 ease-in-out transform hover:scale-105">
                Execute Command
            </button>
        </div>

        <div id="result" class="mt-8 p-6 bg-gray-900 rounded-lg hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Results</h2>
            <div id="loader" class="loader mx-auto hidden"></div>
            <pre id="output" class="text-gray-300 whitespace-pre-wrap text-sm"></pre>
        </div>
        <div id="status-message" class="mt-4 text-center text-green-400 font-medium h-6"></div>
    </div>

    <script>
        // --- SECURITY WARNING ---
        // Storing secret keys directly in your code is highly insecure, even in a private repository.
        // If this code is ever exposed, your keys will be compromised.
        // Replace the placeholder text below with your actual keys.
        const GITHUB_TOKEN = "YOUR_GITHUB_TOKEN_HERE";
        const GEMINI_API_KEY = "YOUR_GEMINI_API_KEY_HERE";


        const executeBtn = document.getElementById('executeBtn');
        const repoUrlInput = document.getElementById('repoUrl');
        const commandInput = document.getElementById('command');
        const resultDiv = document.getElementById('result');
        const outputPre = document.getElementById('output');
        const loader = document.getElementById('loader');

        executeBtn.addEventListener('click', async () => {
            const repoUrl = repoUrlInput.value.trim();
            const command = commandInput.value.trim();
            const token = GITHUB_TOKEN;
            const geminiApiKey = GEMINI_API_KEY;

            resultDiv.classList.remove('hidden');
            loader.classList.remove('hidden');
            outputPre.textContent = '';

            if (token === "YOUR_GITHUB_TOKEN_HERE" || geminiApiKey === "YOUR_GEMINI_API_KEY_HERE") {
                outputPre.textContent = 'ERROR: Please replace the placeholder keys in the index.html file with your actual secret keys.';
                loader.classList.add('hidden');
                return;
            }

            if (!repoUrl || !token || !command || !geminiApiKey) {
                outputPre.textContent = 'Please fill in all required fields: Repo URL and AI Command.';
                loader.classList.add('hidden');
                return;
            }

            try {
                const [owner, repo] = new URL(repoUrl).pathname.slice(1).replace('.git', '').split('/');

                // Step 1: Get repository file structure
                outputPre.textContent = 'Fetching repository structure...\n';
                const files = await getRepoFiles(owner, repo, token);
                const fileStructure = files.map(file => file.path).join('\n');
                outputPre.textContent += 'Done.\n\n';

                // Step 2: Call Gemini API
                outputPre.textContent += 'Asking AI for instructions...\n';
                const aiResponse = await callGeminiApi(command, fileStructure, owner, repo, geminiApiKey);
                outputPre.textContent += "AI Response:\n" + JSON.stringify(aiResponse, null, 2) + "\n\n";

                // Step 3: Execute GitHub actions
                if (aiResponse.actions && Array.isArray(aiResponse.actions)) {
                    for (const action of aiResponse.actions) {
                        await executeGithubAction(owner, repo, token, action);
                    }
                } else {
                     outputPre.textContent += "No actions to perform or invalid format.\n";
                }

            } catch (error) {
                console.error('Error:', error);
                outputPre.textContent += `\n--- ERROR ---\nAn error occurred: ${error.message}`;
            } finally {
                loader.classList.add('hidden');
            }
        });
        
        function showStatusMessage(message) {
            const statusDiv = document.getElementById('status-message');
            statusDiv.textContent = message;
            setTimeout(() => {
                statusDiv.textContent = '';
            }, 3000); // Message disappears after 3 seconds
        }

        async function getRepoFiles(owner, repo, token) {
            const url = `https://api.github.com/repos/${owner}/${repo}/git/trees/main?recursive=1`;
            const response = await fetch(url, {
                headers: {
                    'Authorization': `token ${token}`,
                    'Accept': 'application/vnd.github.v3+json'
                }
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`GitHub API error (getRepoFiles): ${errorData.message}`);
            }
            const data = await response.json();
            return data.tree.filter(node => node.type === 'blob');
        }

        async function callGeminiApi(command, fileStructure, owner, repo, providedApiKey) {
            const apiKey = providedApiKey || ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;

            const systemPrompt = `You are an expert AI assistant that helps manage GitHub repositories. Based on the user's command and the current repository file structure, you will determine the necessary actions to perform.

The possible actions are: 'CREATE', 'UPDATE', 'DELETE', or 'READ'.

Your response MUST be a JSON object with a key "actions" which is an array of action objects.
Each action object should have the following properties:
- "action": The type of action ('CREATE', 'UPDATE', 'DELETE', 'READ').
- "filepath": The full path of the file to be acted upon.
- "content": The content of the file (for 'CREATE' and 'UPDATE' actions). Base64 encode the content. For other actions, this can be an empty string.
- "commitMessage": A descriptive commit message for the action.

When asked to create a CI/CD or build workflow, you should create a GitHub Actions workflow file.
- The file path MUST be inside the '.github/workflows/' directory (e.g., '.github/workflows/ci.yml').
- The content MUST be valid YAML.
- For a 'pull_request' trigger, the structure should be 'on: pull_request: branches: [ main ]' or similar.
- A workflow should contain jobs, and each job has steps. A common first step is checking out the code with 'uses: actions/checkout@v3'.

Example response for creating a CI workflow file:
{
  "actions": [
    {
      "action": "CREATE",
      "filepath": ".github/workflows/ci.yml",
      "content": "bmFtZTogQ0kKCm9uOiAKICBwdWxsX3JlcXVlc3Q6CiAgICBicmFuY2hlczoKICAgICAgLSBtYWluCgpqb2JzOgogIGJ1aWxkOgogICAgcnVucy1vbjo gdWJ1bnR1LWxhdGVzdAogICAgc3RlcHM6CiAgICAgIC0gdXNlczogYWN0aW9ucy9jaGVja291dEB2MwogICAgICAtIG5hbWU6IFJ1biBhIHRlc3QKICAgICAgICBydW46IGVjaG8gIlJ1bm5pbmcgdGVzdHMuLi4iCg==",
      "commitMessage": "ci: add basic CI workflow"
    }
  ]
}

Current repository: ${owner}/${repo}
File structure:
${fileStructure}
`;
            const userQuery = `User command: "${command}"`;

             const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: {
                    parts: [{ text: systemPrompt }]
                },
                 generationConfig: {
                    responseMimeType: "application/json",
                }
            };

            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Gemini API error: ${errorData.error.message}`);
            }

            const result = await response.json();
            const text = result.candidates[0].content.parts[0].text;
            return JSON.parse(text);
        }

       async function executeGithubAction(owner, repo, token, action) {
            outputPre.textContent += `\n-> Executing: ${action.action} on ${action.filepath}...\n`;

            let url, body;

            const headers = {
                'Authorization': `token ${token}`,
                'Accept': 'application/vnd.github.v3+json',
                'Content-Type': 'application/json'
            };

            try {
                switch (action.action) {
                    case 'CREATE':
                    case 'UPDATE':
                        let sha;
                        if (action.action === 'UPDATE') {
                            const fileResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`, { headers });
                            if (fileResponse.ok) {
                                const fileData = await fileResponse.json();
                                sha = fileData.sha;
                            } else {
                                outputPre.textContent += `   - Note: File not found for update. Will create it instead.\n`;
                            }
                        }

                        url = `https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`;
                        body = {
                            message: action.commitMessage,
                            content: action.content,
                            sha: sha
                        };

                        const response = await fetch(url, { method: 'PUT', headers, body: JSON.stringify(body) });
                        if (!response.ok) {
                            const errorData = await response.json();
                            throw new Error(errorData.message);
                        }
                        outputPre.textContent += `   - Success: ${action.action === 'CREATE' ? 'Created' : 'Updated'} ${action.filepath}\n`;
                        break;

                    case 'DELETE':
                        const fileResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`, { headers });
                        if (!fileResponse.ok) throw new Error('File not found to delete.');
                        const fileData = await fileResponse.json();

                        url = `https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`;
                        body = { message: action.commitMessage, sha: fileData.sha };
                        
                        const deleteResponse = await fetch(url, { method: 'DELETE', headers, body: JSON.stringify(body) });
                        if (!deleteResponse.ok) {
                            const errorData = await deleteResponse.json();
                            throw new Error(errorData.message);
                        }
                        outputPre.textContent += `   - Success: Deleted ${action.filepath}\n`;
                        break;

                    case 'READ':
                        const readResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${action.filepath}`, { headers });
                        if (!readResponse.ok) throw new Error('File not found to read.');
                        const data = await readResponse.json();
                        const content = atob(data.content);
                        outputPre.textContent += `   - Content of ${action.filepath}:\n---\n${content}\n---\n`;
                        break;
                        
                    default:
                        outputPre.textContent += `   - Warning: Unknown action '${action.action}' skipped.\n`;
                }
            } catch(e) {
                outputPre.textContent += `   - Error on action ${action.action}: ${e.message}\n`;
            }
        }

    </script>
</body>
</html>

